[
    {
        "idx":0,
        "title": "그린화 패턴1(operator vs bitwise operator)",
        "contents": [
            "그린화 패턴 1은 before에서는 '%' 연산자를 사용하였고 after에서는 비트 연산자를 사용하여 짝수 여부를 확인한다. 비트 연산자를 적용했을 때, 탄소배출량이 줄어든 것을 확인할 수 있다.탄소배출량이 약 2.94% 감소한 것을 확인할 수 있다.",
            "비트 수준에서의 논리 연산이기 때문에 보다 간단하고 효율적으로 코드를 실행할 수 있다."
        ]
    },
    {
        "idx":1,
        "title": "그린화 패턴 2 (Nested Conditionals vs Logical Operators)",
        "contents": [
            "그린화 패턴 2는 before에서는 if문을 반복적으로 사용하여 True 여부를 판단하였고 after에서는 논리식을 통해서 판단한다. 탄소배출량이 약 4.39% 감소한 것을 볼 수 있다.",
            "중첩된 조건문에 비해 논리연산자를 사용했을 때, 코드가 단순하게 작성할 수 있어 간결하고 효율적으로 코드를 실행할 수 있다. "
        ]
    },
    {
        "idx":2,
        "title": "그린화 패턴 3 (Integer Wrapper vs Primitive int)",
        "contents": [
            "그린화 패턴 3에서는 Integer Wrapper과 Primitive int를 적용하여 sum을 한 결과를 비교한다. Before에서는 Integer Wrapper을 사용하였고 After에서는 Primitive int를 사용했다.",
            "탄소배출량이 약 2.65% 감소하였다. Integer는 객체이기 때문에 기본 자료형인 'int'로 변환하는 Autoboxing 과정이 필요하다. 또한, 'int'는 기본 자료형이기 때문에 stack에 저장되고 wrapper에 비해 더 적은 메모리를 사용하여 빠른 연산을 수행할 수 있다."
        ]

    },
    {
        "idx":3,
        "title": "그린화 패턴 4 (Redundant Temporary Variables)",
        "contents": [
            "그린화 패턴 4에서는 불필요한 임시 변수를 사용하지 않는 것이다. Before에서는 a와 b 값을 더할 때, temp 변수를 사용한 반면에 After에서는 temp 변수를 사용하지 않고 바로 덧셈을 시행하였다.",
            "탄소배출량은 약 4.86% 감소되었다. 임시 변수를 사용하지 않고 직접 반환하면 임시 변수를 메모리에 할당하는 과정을 건너뛸 수 있다. 따라서 불필요한 임시 변수는 사용하지 않는 것이 좋다."
        ]
    },
    {
        "idx":4,
        "title": "그린화 패턴 5 (HashSet)",
        "contents": [
            "그린화 패턴 5에서는 HashSet 초기화를 할 때 효율적인 방법을 보여준다. Before에서는 빈 HashSet을 생성한 후에 addAll 매서드를 사용하여 요소를 추가한다. 반면에, After에서는 HashSet의 생성자를 통해 초기 요소를 추가한다.",
            "탄소배출량은 약 6.43% 감소되었다. After에서 초기화 과정을 한 번에 수행하기 때문에 addAll 매서드 호출 없이 HashSet을 초기화할 수 있어서 탄소배출량을 줄일 수 있다."
        ]
    },
    {
        "idx":5,
        "title": "그린화 패턴 6 (ArrayList)",
        "contents": [
            "그린화 패턴 6에서는 ArrayList를 초기화하는 과정에서의 탄소배출량 감소를 보여준다. 그린화 패턴을 적용하였을 때, ArrayList에 asList() 매서드를 사용하여 리스트로 변환하고 addAll() 매서드로 한번에 추가하게 한다. 이는 for문을 통해 요소를 각각 ArrayList에 추가하는 작업을 줄여준다.",
            "탄소배출량이 약 9.62% 감소되었다. ArrayList에 요소를 추가할 때 for문을 사용하지 않고 한번에 추가하는 방법을 통해 탄소배출량을 줄일 수 있다."
        ]
    },
    {
        "idx":6,
        "title": "그린화 패턴 7 (String vs Char)",
        "contents": [
            "그린화 패턴 7에서는 문자 하나를 다룰 때, String과 Char 중 Char을 적용하여 탄소배출량을 감소시켰다. ",
            "탄소배출량은 약 8.19% 감소한 결과를 보였다. String은 문자열을 처리하는 객체이기 때문에, 많은 메모리 공간을 차지한다. 반면 char는 단일 문자를 나타내기 때문에 적은 메모리를 사용하고 연산량을 줄일 수 있다. "
        ]
    },
    {
        "idx":7,
        "title": "그린화 패턴 8 (String Concatenation Using “”)",
        "contents": [
            "그린화 패턴 9은 문자열을 결합할 때 결합할 문자열 앞에 “”도 추가하여 문자열을 결합한다.",
            "탄소배출량 3.55%가 감소되었다. 문자열 연산에 “”을 추가함으로써 문자열과 다른 데이터 타입을 결합할 때 빈 문자열을 먼저 추가함으로써, 문자열로의 변호나 작업을 명시적으로 시작하기 때문에 탄소배출량을 줄일 수 있다. "
        ]
    },
    {
        "idx":8,
        "title": "그린화 패턴 9 (String format vs String concat)",
        "contents": [
            "그린화 패턴 9에서는 문자열을 합칠 때, String.format 대신 concat 매서드를 사용하여 탄소배출량을 감소시켰다.",
            "탄소배출량이 약 4.55% 감소하였다. 작은 규모의 문자열을 연결하는 경우에는 concat을 사용하는 것이 String.format 보다 유리하다. 왜냐하면 Formatter의 형식 지정 방식이 오버헤드를 초래할 수 있기 때문이다."
        ]
    },
    {
        "idx":9,
        "title": "그린화 패턴 10 (Scanner vs BufferedReader)",
        "contents": [
            "그린화 패턴 10에서는 문자열을 한줄씩 읽는 방법을 Scanner에서 BufferedReader로 변경하여 탄소배출량을 감소시켰다. BufferedReader는 대용량의 데이터를 처리하는데 Scanner 보다 빠른 결과를 보였다. ",
            "탄소배출량은 약 38.79% 감소하였다. BufferedReader는 버퍼링을 통해 입출력 성능을 향상시켜 빠른 속도로 입출력을 처리할 수 있다."
        ]
    },
    {
        "idx":10,
        "title": "그린화 패턴 11 (split vs StringTokenizer)",
        "contents": [
            "그린화 패턴 11은 긴 문자열을 공백을 기준을 나눌 때, split을 사용하는 것보다 StringTokenizer을 사용하는 것이 탄소배출량을 줄이는데 도움이 되는 것을 보여준다. ",
            "탄소배출량은 약 3.57% 개선되었다. Split은 정규 표현식을 기반으로 문자열을 분할하는 반면에 StringTokenizer는 구분자 기반으로 문자열을 분할한다. 또한, split은 호출이 될 때마다 정규 표현식을 생성하여 문자열을 처리하기 때문에 객체 생성 및 정규 표현식 해석으로 인한 오버헤드가 발생할 수 있다. 또한, split은 배열을 반환하고 결과를 저장하기 위해 추가적인 메모리 할당이 필요한 반면에 StringTokenizer는 메모리 할당이 필요하지 않기 때문에 탄소배출량 감소에 도움이 된다. "
        ]
    },
    {
        "idx":11,
        "title": "그린화 패턴 12 (One Line Print)",
        "contents": [
            "그린화 패턴 12에서는 문자열을 분할하고 출력하는 방식에서의 개선을 보여준다. Before에서는 BufferedReader을 통해 문자열을 한 줄씩 읽고 출력하지만, 그린화 패턴에서는 split을 사용하여 문자열을 ‘\n’을 기준으로 분할하여 리스트에 저장한 후 반복문을 통해 출력하는 방식을 통해 탄소배출량을 감소시킨다.",
            "약 0.7%의 탄소배출량이 감소되었다. 한번에 문자열을 분할하고 이 결과를 리스트로 저장하여 출력하기 때문에 탄소배출량이 감소된 결과를 보인다."
        ]
    },
    {
        "idx":12,
        "title": "그린화 패턴 13 (Sum array)",
        "contents": [
            "그린화 패턴 13에서는 IntStream을 사용하여 배열의 합을 구한 것을 for문을 통해 배열 요소를 합산하는 방식을 적용하여 탄소배출량을 감소시켰다.",
            "Before에 비해 After에서 19.66%의 탄소배출량이 감소되었다. IntStream을 사용하여 배열의 합을 구할 때에는 내부적으로 데이터를 Stream으로 변환하고 합을 구하는 작업이 발생한다. 반면에, for문을 통해 배열 요소를 직접 더하는 경우는 오버헤드 없이 진행할 수 있다."
        ]
    },
    {
        "idx":13,
        "title": "그린화 패턴 14 (Filtering)",
        "contents": [
            "그린화 패턴 14에서는 짝수를 판별하는 코드를 filter 매서드 대신 조건문을 사용하여 탄소배출량을 감소시켰다. Before에서는 stream을 사용하여 filtering을 수행하고 그 결과를 리스트에 저장하였다. 반면 After에서는 반복문을 통해 짝수 필터링된 값을 바로 새 리스트에 추가하는 방식을 사용했다.",
            "그 결과, 탄소배출량이 9.43% 감소되었다. Stream 내부에서 필터링을 하고 연산을 수행하는 과정에서 오버헤드가 발생할 수 있다. 따라서, 직접적으로 조건문을 통해 필터링을 하고 반복문을 통해 리스트를 추가하는 과정이 더 적은 작업을 수행하여 탄소배출량을 줄일 수 있다."
        ]
    },
    {
        "idx":14,
        "title": "그린화 패턴 15 (Sorting by age)",
        "contents": [
            "그린화 패턴 15에서는 Collection.sort와 comparator을 통해 정렬을 하여 탄소배출량을 감소시키는 패턴이다. Before에서는 Stream을 통해 정렬을 수행한다. 반면에 After에서는 Collection.sort를 사용하여 Comparator를 정의하고 이를 통해 나이순으로 정렬한다. ",
            "그 결과, 18.03%의 탄소배출량이 감소되었다. 그 이유는 Collections.sort()가 Stream보다 오버헤드가 적게 정렬을 수행할 수 있기 때문에 탄소배출량을 감소시킬 수 있다."
        ]
    },
    {
        "idx":15,
        "title": "그린화 패턴 16 (String vs StringBuffer)",
        "contents": [
            "그린화 패턴 16에서는 StringBuffer을 사용하여 문자열을 사용할 때, 새로운 객체를 생성하는 오버헤드를 줄여 메모리 사용량과 런타임을 줄임으로써 탄소배출량을 줄일 수 있게 했다.",
            "탄소배출량이 1.44% 감소한 결과를 보였다. StringBuffer은 내부 버퍼에 문자열을 저장하고 필요할 때, 버퍼의 크기를 조절하면서 문자열을 변경한다. 따라서, 문자열을 추가하거나 변경할 때마다 새로운 객체를 생성하지 않고 기존 버퍼를 통해 문자열을 조작한다. 따라서, 문자열이 길거나 반복적으로 문자열을 변경할 때에는 StringBuffer을 사용하는 것이 메모리 사용량과 런타임을 줄이는데 도움이 되며 이는 탄소배출량 절감을 가능하게 한다."
        ]
    },
    {
        "idx":16,
        "title": "그린화 패턴 17 (Array copy)",
        "contents": [
            "그린화 패턴 17은 배열을 복사할 때, 전체 배열을 복사하는 것은 메모리 낭비가 발생할 수 있기 때문에 범위 지정을 한 후에 배열을 복사를 할 때, 탄소배출량이 절감한 것을 보여준다.",
            "패턴 적용 후에 탄소배출량이 5.09% 감소하였다. Arrays.copyOfRange를 통해 원하는 범위의 데이터를 복사할 수 있다. 이를 통해 메모리와 시간을 절약할 수 있다. 이는 실제로 필요한 범위만 복사하기 때문이다."
        ]
    },
    {
        "idx":17,
        "title": "그린화 패턴 18 (ArrayList vs LinkedList)",
        "contents": [
            "그린화 패턴 18에서는 순차적으로 배열의 요소를 검색하고 출력하는 동작에서 ArrayList보다 LinkedList가 더 효율적임을 보여준다. ",
            "탄소배출량이 3.88% 감소한 결과를 보인다. LinkedList는 노드의 이전 노드와 다음 노드에 대해 참조를 가지고 있어 순차적으로 노드를 접근하는데 효율적이다. 따라서, List를 순차적으로 순회할 때에는 LinkedList를 사용하는 것이 탄소배출량을 줄이는데 도움이 된다."
        ]
    },
    {
        "idx":18,
        "title": "그린화 패턴 19 (equal vs comparedTo)",
        "contents": [
            "그린화 패턴 19에서는 문자열을 비교할 때, equal 매서드 보다 comparedTo를 사용하는 것이 탄소배출량 감소에 도움이 되는 것을 보여준다. 해당 코드에서는 대소문자를 무시하고 문자열을 비교하는 코드이다.",
            "탄소배출량이 1.37% 감소하였다.  Equals 매서드는 비교 결과를 Boolean으로 반환하며 compareTo 매서드는 비교 결과를 정수값으로 반환한다. 매서드 내부 구현 방식의 차이로 탄소배출량 감소에 도움이 된다. "
        ]
    },
    {
        "idx":19,
        "title": "그린화 패턴 20 (Memory Management)",
        "contents": [
            "그린화 패턴 20은 문자열을 생성할 때, 객체를 재사용하여 문자열을 생성하는 방식을 사용하여 메모리 할당 및 객체 생성에 대한 오버헤드를 감소시키는 방법으로 탄소배출량을 감소시켰다. ",
            "탄소배출량이 13.71% 감소한 결과를 보였다. 반복문 안에서 이전 문자열을 setLength(0)을 통해 초기화하고 새로운 문자열을 생성한다. 이는 StringBuilder를 재사용하기 때문에 객체 생성을 최소화 시킬 수 있고 탄소배출량을 감소시키는 결과를 보인다."
        ]
    }
]